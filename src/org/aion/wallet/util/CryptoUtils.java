/*
 * Copyright (c) 2017-2018 Aion foundation.
 *
 *     This file is part of the aion network project.
 *
 *     The aion network project is free software: you can redistribute it
 *     and/or modify it under the terms of the GNU General Public License
 *     as published by the Free Software Foundation, either version 3 of
 *     the License, or any later version.
 *
 *     The aion network project is distributed in the hope that it will
 *     be useful, but WITHOUT ANY WARRANTY; without even the implied
 *     warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *     See the GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with the aion network project source files.
 *     If not, see <https://www.gnu.org/licenses/>.
 *
 * Contributors:
 *     Aion foundation.
 */
package org.aion.wallet.util;

import io.github.novacrypto.bip39.SeedCalculator;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import javax.crypto.Mac;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import org.aion.crypto.ECKey;
import org.aion.crypto.ed25519.ECKeyEd25519;
import org.aion.wallet.exception.ValidationException;

/**
 * Utilities for calculations used in SLIP-0010 key derivation.
 *
 * <p>See: https://github.com/satoshilabs/slips/blob/master/slip-0010.md
 */
public final class CryptoUtils {

    /** ed25519 curve seed, as specified in SLIP-0010 */
    public static final byte[] ED25519_KEY = "ed25519 seed".getBytes();

    private static final String HMAC_SHA512_ALGORITHM = "HmacSHA512";
    private static final String DEFAULT_MNEMONIC_PASSPHRASE = "";
    private static final int HARDENED_KEY_MULTIPLIER = 0x80000000;
    private static final ECKeyEd25519 EC_KEY_FACTORY = new ECKeyEd25519();

    private CryptoUtils() {}

    /**
     * Create an {@link ECKey} with private key I, which can be used as the master key for
     * SLIP-0010. I is calculated by computing a 512-bit byte sequence for given mnemonic according
     * to BIP-0039, then hashing that sequence with HMAC-SHA512.
     *
     * @param mnemonic mnemonic for BIP39-generated byte sequence seed
     * @return ECKey with private key I = HMAC-SHA256(BIP39(mnemonic))
     * @throws ValidationException
     */
    public static ECKey generateSha512HashedBip39ECKey(final String mnemonic)
            throws ValidationException {
        final byte[] seed =
                new SeedCalculator().calculateSeed(mnemonic, DEFAULT_MNEMONIC_PASSPHRASE);
        return getECKey(hashSha512(ED25519_KEY, seed));
    }

    /**
     * HMAC-SHA512 hash function.
     *
     * @param secret secret
     * @param hashData hash data
     * @return HMAC-SHA12 hash of secret and hashdata
     * @throws ValidationException
     */
    public static byte[] hashSha512(final byte[] secret, final byte[] hashData)
            throws ValidationException {
        final byte[] bytes;
        try {
            final Mac mac = Mac.getInstance(HMAC_SHA512_ALGORITHM);
            final SecretKey key = new SecretKeySpec(secret, HMAC_SHA512_ALGORITHM);
            mac.init(key);
            bytes = mac.doFinal(hashData);
        } catch (NoSuchAlgorithmException | InvalidKeyException e) {
            throw new ValidationException(e);
        }
        return bytes;
    }

    /**
     * Harden derivation path number
     *
     * @param number number to harden
     * @return hardened number
     */
    public static byte[] hardenedNumber(final int number) {
        final ByteBuffer byteBuffer = ByteBuffer.allocate(4);
        byteBuffer.order(ByteOrder.BIG_ENDIAN);
        byteBuffer.putInt(number | HARDENED_KEY_MULTIPLIER);
        return byteBuffer.array();
    }

    /**
     * Create EC Key from given privateKey
     *
     * @param privateKey private key of EC Key
     * @return EC Key containing privateKey
     */
    public static ECKey getECKey(final byte[] privateKey) {
        return EC_KEY_FACTORY.fromPrivate(privateKey);
    }
}
